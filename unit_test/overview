# principles
  1) each test unit must be fully independent, regardless of the order they are called
     a) each test is loaded with a fresh dataset, and do cleanup afterwards
     b) handled by setUp() and tearDown() methods
  2) run the tests often
     a) ideally run the function's test automatically whenever saving the code
     b) always run the full test suite before a coding session, and run it again after
     c) implement a hook that runs all tests before pushing code to a shared repository
  3) when to write new tests
     a) write a broken unit test about what you want to develop next
     b) when debugging the code: write a new test pinpointing the bug
  4) use long and descriptive names for testing functions
     function names will be displayed when a test fails
     ex. test_square_of_number_2() / test_square_negative_number() ==> instead of test_square()

# what to tests
  1) module interface
     whether information are properly passed into and out of the module (unit)
  2) local data structure
     whether the local data is properly stored within the module (unit)
  3) boundary conditions
     whether the boundary conditions work as expected
  4) error handling
     whether the errors are properly handled
  5) independent paths
     whether all independent paths to see are properly executed and terminated at the end of the program

# test double
  objects or procedures that look and behave like their release / production counterparts
  types of test double
  1) test stub: providing the tested code with "indirect input"
  2) mock object: for verifying "indirect output" of the tested code
                  by first defining the expectations before the tested code is executed
  3) test spy: for verifying "indirect output" of the tested code
               by asserting the expectations afterwards, instead of defining the expectations
  4) fake object: used as a simpler implementation
                  ex. using an in-memory database instead of doing a real database access
  5) dummy object: when a parameter is needed but not used by the tested method
 
# structure of project directory
  PROJECT_DIR
  |-- mycalc/
  |   |-- calc.py                <== app name (class: App) 
  |    -- __init__.py
   -- tests/
      |-- __init__.py
       -- unit/
          |-- __init__.py
           -- test_calc.py       <== test_app (class: TestApp, function: test_functionality_long_description)

  Python does not add the current directory to sys.path, but rather the directory that the script is in
  1) need to add current directory to either sys.path or $PYTHONPATH:
  2) add to .bashrc / .bash_profile / .profile
     export PYTHONPATH=$PYTHONPATH:.

# run unit tests
  1) python tests/unit/test_calc.py
       need to have unittest.main() in test_calc.py

       if __name__ == '__main__':
           unittest.main()

  2) python -m unittest tests.unit.test_calc          ==> run a single test
       do not need unittest.main() in testing modules
  3) python -m unittest discover tests/unit           ==> test discovery
       will look for all tests/unit/test*.py (Python2.7 support test discovery)

# install mock under virtualenv
  cd /path/to/source/directory
  virtualenv env                 ==> will create an env/ directory
  . ./env/bin/activate           ==> enter virtualenv
  pip install mock
  deactivate                     ==> exit virtualenv

# nose
  nosetests -w /path/to/tests/                        ==> test discoverty
    -w: specifying the working directory
  nosetests /path/to/tests/test_app.py                ==> run a single test


